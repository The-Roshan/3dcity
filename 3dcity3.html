<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Realistic 3D Village Scene with More Elements</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
        }
        canvas {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="villageCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            try {
                const testCanvas = document.createElement('canvas');
                if (!testCanvas.getContext('webgl') && !testCanvas.getContext('experimental-webgl')) {
                    document.body.innerHTML = "<h1 style='color: white; text-align: center; margin-top: 50px;'>WebGL is not supported. Use a modern browser like Chrome or Firefox.</h1>";
                    return;
                }

                const canvas = document.getElementById("villageCanvas");
                const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(40, 35, 45);
                camera.lookAt(0, 0, 0);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);

                const sunlight = new THREE.DirectionalLight(0xfff5e6, 1.2);
                sunlight.position.set(25, 50, 25);
                sunlight.castShadow = true;
                sunlight.shadow.mapSize.width = 2048;
                sunlight.shadow.mapSize.height = 2048;
                sunlight.shadow.camera.near = 0.5;
                sunlight.shadow.camera.far = 120;
                sunlight.shadow.camera.left = -50;
                sunlight.shadow.camera.right = 50;
                sunlight.shadow.camera.top = 50;
                sunlight.shadow.camera.bottom = -50;
                scene.add(sunlight);

                // Ground
                const groundGeometry = new THREE.PlaneBufferGeometry(100, 100, 20, 20);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2f4f2f, roughness: 0.9, metalness: 0 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                const groundPositions = groundGeometry.attributes.position;
                for (let i = 0; i < groundPositions.count; i++) {
                    const z = groundPositions.getZ(i);
                    groundPositions.setZ(i, z + (Math.random() * 1.5 - 0.75));
                }
                groundPositions.needsUpdate = true;
                scene.add(ground);

                // Houses
                function createHouse(x, z, scale = 1) {
                    const house = new THREE.Group();
                    const wallGeometry = new THREE.BoxBufferGeometry(6 * scale, 4 * scale, 6 * scale);
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D, 
                        roughness: 0.8, 
                        metalness: 0.1 
                    });
                    const walls = new THREE.Mesh(wallGeometry, wallMaterial);
                    walls.position.y = 2 * scale;
                    walls.castShadow = true;
                    walls.receiveShadow = true;
                    house.add(walls);

                    const doorGeometry = new THREE.BoxBufferGeometry(1.2 * scale, 2.8 * scale, 0.1 * scale);
                    const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033 });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 1.4 * scale, 3.05 * scale);
                    house.add(door);

                    const windowGeometry = new THREE.BoxBufferGeometry(1 * scale, 1 * scale, 0.1 * scale);
                    const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, roughness: 0.2 });
                    const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window1.position.set(2 * scale, 2 * scale, 3.05 * scale);
                    house.add(window1);
                    const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window2.position.set(-2 * scale, 2 * scale, 3.05 * scale);
                    house.add(window2);

                    const roofGeometry = new THREE.ConeBufferGeometry(4 * scale, 3 * scale, 4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 4.5 * scale;
                    roof.rotation.y = Math.PI / 4;
                    roof.castShadow = true;
                    house.add(roof);

                    const chimneyGeometry = new THREE.BoxBufferGeometry(0.6 * scale, 1.5 * scale, 0.6 * scale);
                    const chimneyMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                    const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
                    chimney.position.set(2 * scale, 5 * scale, -1 * scale);
                    chimney.castShadow = true;
                    house.add(chimney);

                    house.position.set(x, 0, z);
                    scene.add(house);
                }

                createHouse(8, 8, 1);
                createHouse(-12, 6, 0.9);
                createHouse(-10, -12, 1);
                createHouse(-18, 12, 0.8);
                createHouse(22, -8, 1.1);
                createHouse(25, 12, 0.95);
                createHouse(-22, 16, 1.2);
                createHouse(28, -12, 0.85);

                // Huts
                function createHut(x, z) {
                    const hut = new THREE.Group();
                    const baseGeometry = new THREE.CylinderBufferGeometry(2.5, 2.5, 3, 12);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 1.5;
                    base.castShadow = true;
                    hut.add(base);

                    const roofGeometry = new THREE.ConeBufferGeometry(3, 2.5, 12);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x964B00, roughness: 0.8 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 3.25;
                    roof.castShadow = true;
                    hut.add(roof);

                    hut.position.set(x, 0, z);
                    scene.add(hut);
                }

                createHut(-15, -15);
                createHut(16, -16);
                createHut(-22, 20);

                // Trees
                function createTree(x, z, scale = 1) {
                    const trunkGeometry = new THREE.CylinderBufferGeometry(0.3 * scale, 0.4 * scale, 4 * scale, 12);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.9 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, 2 * scale, z);
                    trunk.castShadow = true;
                    scene.add(trunk);

                    const leavesGeometry = new THREE.SphereBufferGeometry(2.5 * scale, 16, 16);
                    const leavesMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0x228B22 : 0x006400, 
                        roughness: 0.7 
                    });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(x, 5 * scale, z);
                    leaves.castShadow = true;
                    scene.add(leaves);
                }

                createTree(12, 12);
                createTree(-7, 14);
                createTree(9, -9);
                createTree(-15, 7);
                createTree(20, -6);
                createTree(-25, 10);
                createTree(27, 16, 0.9);
                createTree(-17, -17, 1.1);
                createTree(30, -20);

                // Forest Cluster
                for (let i = 0; i < 8; i++) {
                    const x = 35 + Math.random() * 10 - 5;
                    const z = 35 + Math.random() * 10 - 5;
                    createTree(x, z, 0.8 + Math.random() * 0.4);
                }

                // Rivers and Ponds
                const riverGeometry = new THREE.PlaneBufferGeometry(30, 8);
                const riverMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF, side: THREE.DoubleSide, roughness: 0.1, metalness: 0.3 });
                const river = new THREE.Mesh(riverGeometry, riverMaterial);
                river.rotation.x = -Math.PI / 2;
                river.position.set(0, 0.01, 22);
                scene.add(river);

                const pondGeometry = new THREE.CircleBufferGeometry(6, 32);
                const pondMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF, roughness: 0.1, metalness: 0.3 });
                const pond = new THREE.Mesh(pondGeometry, pondMaterial);
                pond.rotation.x = -Math.PI / 2;
                pond.position.set(-30, 0.01, 30);
                scene.add(pond);

                const pond2 = new THREE.Mesh(pondGeometry, pondMaterial);
                pond2.rotation.x = -Math.PI / 2;
                pond2.position.set(32, 0.01, -22);
                scene.add(pond2);

                // Bridge
                const bridgeGeometry = new THREE.BoxBufferGeometry(5, 0.5, 9);
                const bridgeMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.8 });
                const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
                bridge.position.set(0, 0.5, 22);
                bridge.castShadow = true;
                bridge.receiveShadow = true;
                scene.add(bridge);

                // Fields
                function createField(x, z) {
                    const fieldGeometry = new THREE.PlaneBufferGeometry(12, 12);
                    const fieldMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                    const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                    field.rotation.x = -Math.PI / 2;
                    field.position.set(x, 0.02, z);
                    scene.add(field);

                    const cropGeometry = new THREE.BoxBufferGeometry(0.4, 2, 0.4);
                    const cropMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                    for (let i = -5; i <= 5; i += 1) {
                        for (let j = -5; j <= 5; j += 1) {
                            const crop = new THREE.Mesh(cropGeometry, cropMaterial);
                            crop.position.set(x + i + Math.random() * 0.3, 1, z + j + Math.random() * 0.3);
                            crop.rotation.y = Math.random() * Math.PI;
                            crop.castShadow = true;
                            scene.add(crop);
                        }
                    }
                }

                createField(30, 30);
                createField(-30, -30);

                // Animals
                const cows = [];
                function createCow(x, z) {
                    const cow = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(2.5, 1.5, 1.2);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.8 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.75;
                    body.castShadow = true;
                    cow.add(body);

                    const headGeometry = new THREE.BoxBufferGeometry(1, 1, 1);
                    const head = new THREE.Mesh(headGeometry, bodyMaterial);
                    head.position.set(0, 1, 1.1);
                    head.castShadow = true;
                    cow.add(head);

                    const legGeometry = new THREE.BoxBufferGeometry(0.4, 1.2, 0.4);
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                        leg.position.set(i % 2 === 0 ? 1 : -1, 0.3, i < 2 ? 0.4 : -0.4);
                        leg.castShadow = true;
                        cow.add(leg);
                    }

                    cow.position.set(x, 0, z);
                    scene.add(cow);
                    cows.push({ mesh: cow, velocity: new THREE.Vector3(0.01, 0, 0) });
                }

                createCow(16, 14);
                createCow(18, 12);
                createCow(-24, -10);

                const goats = [];
                function createGoat(x, z) {
                    const goat = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(1.5, 1, 0.8);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.8 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.5;
                    body.castShadow = true;
                    goat.add(body);

                    const headGeometry = new THREE.BoxBufferGeometry(0.6, 0.6, 0.6);
                    const head = new THREE.Mesh(headGeometry, bodyMaterial);
                    head.position.set(0, 0.7, 0.7);
                    head.castShadow = true;
                    goat.add(head);

                    const legGeometry = new THREE.BoxBufferGeometry(0.25, 0.8, 0.25);
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                        leg.position.set(i % 2 === 0 ? 0.6 : -0.6, 0.25, i < 2 ? 0.25 : -0.25);
                        leg.castShadow = true;
                        goat.add(leg);
                    }

                    goat.position.set(x, 0, z);
                    scene.add(goat);
                    goats.push({ mesh: goat, velocity: new THREE.Vector3(0.01, 0, 0) });
                }

                createGoat(20, 10);
                createGoat(-17, -12);

                const chickens = [];
                function createChicken(x, z) {
                    const chicken = new THREE.Group();
                    const bodyGeometry = new THREE.SphereBufferGeometry(0.5, 16, 16);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFA500, roughness: 0.7 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.5;
                    body.castShadow = true;
                    chicken.add(body);

                    const headGeometry = new THREE.SphereBufferGeometry(0.25, 12, 12);
                    const head = new THREE.Mesh(headGeometry, bodyMaterial);
                    head.position.set(0, 0.6, 0.5);
                    head.castShadow = true;
                    chicken.add(head);

                    const beakGeometry = new THREE.ConeBufferGeometry(0.15, 0.25, 8);
                    const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFF4500 });
                    const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                    beak.position.set(0, 0.6, 0.65);
                    beak.rotation.x = -Math.PI / 2;
                    beak.castShadow = true;
                    chicken.add(beak);

                    chicken.position.set(x, 0, z);
                    scene.add(chicken);
                    chickens.push({ mesh: chicken, velocity: new THREE.Vector3(0.005, 0, 0) });
                }

                createChicken(14, 6);
                createChicken(15, 5);
                createChicken(-12, -11);

                // Roads/Paths
                const roadGeometry = new THREE.PlaneBufferGeometry(40, 5);
                const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.set(0, 0.03, 0);
                scene.add(road);

                const pathGeometry = new THREE.PlaneBufferGeometry(5, 30);
                const path = new THREE.Mesh(pathGeometry, roadMaterial);
                path.rotation.x = -Math.PI / 2;
                path.position.set(15, 0.03, 7);
                scene.add(path);

                // People
                const people = [];
                function createPerson(x, z) {
                    const person = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(0.7, 2, 0.7);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() * 0xffffff, 
                        roughness: 0.8 
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1;
                    body.castShadow = true;
                    person.add(body);

                    const headGeometry = new THREE.SphereBufferGeometry(0.4, 16, 16);
                    const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDAB9 });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 2;
                    head.castShadow = true;
                    person.add(head);

                    const armGeometry = new THREE.BoxBufferGeometry(0.35, 1, 0.35);
                    const armMaterial = new THREE.MeshStandardMaterial({ color: bodyMaterial.color });
                    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                    leftArm.position.set(0.7, 1.3, 0);
                    leftArm.castShadow = true;
                    person.add(leftArm);
                    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                    rightArm.position.set(-0.7, 1.3, 0);
                    rightArm.castShadow = true;
                    person.add(rightArm);

                    person.position.set(x, 0, z);
                    scene.add(person);
                    people.push({ mesh: person, velocity: new THREE.Vector3(0.02, 0, 0) });
                }

                createPerson(4, 4);
                createPerson(-5, -3);
                createPerson(15, 3);

                // Wells
                function createWell(x, z) {
                    const well = new THREE.Group();
                    const baseGeometry = new THREE.CylinderBufferGeometry(1.5, 1.5, 2.5, 16);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.6 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 1.25;
                    base.castShadow = true;
                    well.add(base);

                    const roofGeometry = new THREE.ConeBufferGeometry(1.8, 2, 16);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 3;
                    roof.castShadow = true;
                    well.add(roof);

                    well.position.set(x, 0, z);
                    scene.add(well);
                }

                createWell(7, -14);
                createWell(-20, 8);

                // Temples
                function createTemple(x, z) {
                    const temple = new THREE.Group();
                    const baseGeometry = new THREE.BoxBufferGeometry(8, 6, 10);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.5 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 3;
                    base.castShadow = true;
                    temple.add(base);

                    const roofGeometry = new THREE.BoxBufferGeometry(9, 2, 11);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.6 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 6;
                    roof.castShadow = true;
                    temple.add(roof);

                    const steepleGeometry = new THREE.CylinderBufferGeometry(0.6, 0.8, 5, 16);
                    const steeple = new THREE.Mesh(steepleGeometry, baseMaterial);
                    steeple.position.set(0, 8.5, 0);
                    steeple.castShadow = true;
                    temple.add(steeple);

                    temple.position.set(x, 0, z);
                    scene.add(temple);
                }

                createTemple(-18, -18);
                createTemple(25, 20);

                // Fences
                function createFence(xStart, zStart, length, direction = 'x') {
                    const fence = new THREE.Group();
                    const postGeometry = new THREE.CylinderBufferGeometry(0.2, 0.2, 3, 8);
                    const railGeometry = new THREE.BoxBufferGeometry(2.5, 0.2, 0.2);
                    const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.8 });

                    for (let i = 0; i < length; i++) {
                        const post = new THREE.Mesh(postGeometry, fenceMaterial);
                        post.position.y = 1.5;
                        if (direction === 'x') post.position.set(xStart + i * 2.5, 0, zStart);
                        else post.position.set(xStart, 0, zStart + i * 2.5);
                        post.castShadow = true;
                        fence.add(post);

                        if (i < length - 1) {
                            const rail = new THREE.Mesh(railGeometry, fenceMaterial);
                            rail.position.y = 1.5;
                            if (direction === 'x') rail.position.set(xStart + i * 2.5 + 1.25, 0, zStart);
                            else rail.position.set(xStart, 0, zStart + i * 2.5 + 1.25);
                            rail.castShadow = true;
                            fence.add(rail);
                        }
                    }

                    scene.add(fence);
                }

                createFence(-8, -8, 5, 'x');
                createFence(8, -10, 4, 'z');
                createFence(20, 14, 5, 'x');
                createFence(-25, -8, 4, 'z');

                // Mountains
                function createMountain(x, z, scale = 1) {
                    const mountain = new THREE.Group();
                    const baseGeometry = new THREE.ConeBufferGeometry(15 * scale, 10 * scale, 12);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 5 * scale;
                    base.castShadow = true;
                    mountain.add(base);

                    const midGeometry = new THREE.ConeBufferGeometry(8 * scale, 6 * scale, 12);
                    const midMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.6 });
                    const mid = new THREE.Mesh(midGeometry, midMaterial);
                    mid.position.y = 11 * scale;
                    mid.castShadow = true;
                    mountain.add(mid);

                    const peakGeometry = new THREE.ConeBufferGeometry(4 * scale, 4 * scale, 12);
                    const peakMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.5 });
                    const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                    peak.position.y = 15 * scale;
                    peak.castShadow = true;
                    mountain.add(peak);

                    const rockGeometry = new THREE.SphereBufferGeometry(1.5 * scale, 8, 8);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
                    for (let i = 0; i < 8; i++) {
                        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                        rock.position.set(
                            (Math.random() - 0.5) * 12 * scale,
                            Math.random() * 8 * scale,
                            (Math.random() - 0.5) * 12 * scale
                        );
                        rock.castShadow = true;
                        mountain.add(rock);
                    }

                    mountain.position.set(x, 0, z);
                    scene.add(mountain);
                }

                createMountain(45, 45, 1);
                createMountain(-45, -45, 1.3);
                createMountain(40, -40, 0.9);

                // Windmill
                function createWindmill(x, z) {
                    const windmill = new THREE.Group();

                    const baseGeometry = new THREE.CylinderBufferGeometry(1.5, 1.5, 2, 16);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 1;
                    base.castShadow = true;
                    windmill.add(base);

                    const towerGeometry = new THREE.CylinderBufferGeometry(1, 1.5, 10, 16);
                    const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.6 });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.y = 6;
                    tower.castShadow = true;
                    windmill.add(tower);

                    const blades = new THREE.Group();
                    const bladeGeometry = new THREE.BoxBufferGeometry(8, 0.2, 0.4);
                    const bladeMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5F5, roughness: 0.7 });
                    for (let i = 0; i < 4; i++) {
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.z = 0.4;
                        blade.rotation.y = (Math.PI / 2) * i;
                        blade.castShadow = true;
                        blades.add(blade);
                    }
                    blades.position.set(0, 11, 0);
                    windmill.add(blades);

                    windmill.position.set(x, 0, z);
                    scene.add(windmill);
                    return blades;
                }

                const windmillBlades = createWindmill(-8, -15);

                // Barn
                function createBarn(x, z) {
                    const barn = new THREE.Group();
                    const baseGeometry = new THREE.BoxBufferGeometry(10, 6, 12);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 3;
                    base.castShadow = true;
                    barn.add(base);

                    const roofGeometry = new THREE.BoxBufferGeometry(11, 2, 13);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 6;
                    roof.castShadow = true;
                    barn.add(roof);

                    const doorGeometry = new THREE.BoxBufferGeometry(3, 4, 0.1);
                    const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033 });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 2, 6.05);
                    barn.add(door);

                    barn.position.set(x, 0, z);
                    scene.add(barn);
                }

                createBarn(20, -20);

                // Cart
                function createCart(x, z) {
                    const cart = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(3, 1, 2);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1;
                    body.castShadow = true;
                    cart.add(body);

                    const wheelGeometry = new THREE.CylinderBufferGeometry(0.5, 0.5, 0.3, 16);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.7 });
                    for (let i = 0; i < 4; i++) {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.x = Math.PI / 2;
                        wheel.position.set(i % 2 === 0 ? 1.3 : -1.3, 0.5, i < 2 ? 0.7 : -0.7);
                        wheel.castShadow = true;
                        cart.add(wheel);
                    }

                    cart.position.set(x, 0, z);
                    scene.add(cart);
                }

                createCart(10, 0);

                // Bushes
                function createBush(x, z, scale = 1) {
                    const bushGeometry = new THREE.SphereBufferGeometry(1.2 * scale, 16, 16);
                    const bushMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0x2E8B57 : 0x228B22, 
                        roughness: 0.8 
                    });
                    const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                    bush.position.set(x, 0.6 * scale, z);
                    bush.castShadow = true;
                    scene.add(bush);
                }

                createBush(5, 9, 1);
                createBush(-4, -12, 0.8);
                createBush(10, 6, 1.2);
                createBush(23, 4, 0.9);
                createBush(-10, 18, 1);

                // Rocks
                function createRock(x, z, scale = 1) {
                    const rockGeometry = new THREE.SphereBufferGeometry(1 * scale, 8, 8);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(x, 0.5 * scale, z);
                    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    rock.castShadow = true;
                    scene.add(rock);
                }

                createRock(15, 15, 1);
                createRock(-15, -5, 0.8);
                createRock(5, -20, 1.2);

                // Sun
                const sunGeometry = new THREE.SphereBufferGeometry(2.5, 32, 32);
                const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFE0 });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                sun.position.set(25, 30, 25);
                scene.add(sun);

                // Clouds
                const clouds = [];
                function createCloud(x, y, z) {
                    const cloud = new THREE.Group();
                    const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.9 });
                    for (let i = 0; i < 6; i++) {
                        const puffGeometry = new THREE.SphereBufferGeometry(1.8 + Math.random() * 0.5, 16, 16);
                        const puff = new THREE.Mesh(puffGeometry, cloudMaterial);
                        puff.position.set(i * 2.5 - 6, Math.random() * 0.8, Math.random() * 1.5);
                        puff.castShadow = true;
                        cloud.add(puff);
                    }
                    cloud.position.set(x, y, z);
                    scene.add(cloud);
                    clouds.push(cloud);
                }

                createCloud(15, 18, 7);
                createCloud(-12, 20, -5);
                createCloud(20, 19, -7);
                createCloud(-20, 21, 14);

                // Birds
                const birds = [];
                function createBird(x, y, z) {
                    const bird = new THREE.Group();
                    const bodyGeometry = new THREE.SphereBufferGeometry(0.3, 16, 16);
                    const wingGeometry = new THREE.BoxBufferGeometry(0.7, 0.05, 0.5);
                    const birdMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });

                    const body = new THREE.Mesh(bodyGeometry, birdMaterial);
                    body.castShadow = true;
                    bird.add(body);

                    const leftWing = new THREE.Mesh(wingGeometry, birdMaterial);
                    leftWing.position.set(0.4, 0, 0);
                    leftWing.castShadow = true;
                    bird.add(leftWing);

                    const rightWing = new THREE.Mesh(wingGeometry, birdMaterial);
                    rightWing.position.set(-0.4, 0, 0);
                    rightWing.castShadow = true;
                    bird.add(rightWing);

                    bird.position.set(x, y, z);
                    scene.add(bird);
                    birds.push({ mesh: bird, velocity: new THREE.Vector3(0.05, 0, 0) });
                }

                createBird(7, 14, 7);
                createBird(-7, 16, -7);
                createBird(14, 19, -4);
                createBird(-14, 18, 4);

                const controls = new THREE.OrbitControls(camera, canvas);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                window.addEventListener('resize', () => {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                });

                let time = 0;
                function animate() {
                    requestAnimationFrame(animate);
                    time += 0.02;

                    sun.scale.set(
                        1 + Math.sin(time) * 0.05,
                        1 + Math.sin(time) * 0.05,
                        1 + Math.sin(time) * 0.05
                    );

                    windmillBlades.rotation.x += 0.05;

                    clouds.forEach(cloud => {
                        cloud.position.x += 0.02;
                        if (cloud.position.x > 50) cloud.position.x = -50;
                    });

                    birds.forEach(bird => {
                        bird.mesh.position.add(bird.velocity);
                        bird.mesh.children[1].rotation.z = Math.sin(time * 2) * 0.5;
                        bird.mesh.children[2].rotation.z = -Math.sin(time * 2) * 0.5;
                        if (bird.mesh.position.x > 45 || bird.mesh.position.x < -45) {
                            bird.velocity.x *= -1;
                        }
                    });

                    cows.forEach(cow => {
                        cow.mesh.position.add(cow.velocity);
                        if (cow.mesh.position.x > 25 || cow.mesh.position.x < 14) {
                            cow.velocity.x *= -1;
                        }
                    });

                    goats.forEach(goat => {
                        goat.mesh.position.add(goat.velocity);
                        if (goat.mesh.position.x > 25 || goat.mesh.position.x < -25) {
                            goat.velocity.x *= -1;
                        }
                    });

                    chickens.forEach(chicken => {
                        chicken.mesh.position.add(chicken.velocity);
                        if (chicken.mesh.position.x > 18 || chicken.mesh.position.x < -18) {
                            chicken.velocity.x *= -1;
                        }
                    });

                    people.forEach(person => {
                        person.mesh.position.add(person.velocity);
                        if (person.mesh.position.x > 18 || person.mesh.position.x < -18) {
                            person.velocity.x *= -1;
                        }
                    });

                    renderer.render(scene, camera);
                    controls.update();
                }
                animate();

                console.log("Ultra-Realistic 3D Village Scene initialized successfully!");
            } catch (error) {
                console.error("Error initializing scene:", error);
                document.body.innerHTML = "<h2 style='color: red; text-align: center; margin-top: 50px;'>Error loading scene. Check console (F12) for details.</h2>";
            }
        });
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Luxurious Responsive 3D Village Scene - Error-Free</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
        }
        canvas {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="villageCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            try {
                // Check WebGL support
                const testCanvas = document.createElement('canvas');
                if (!testCanvas.getContext('webgl') && !testCanvas.getContext('experimental-webgl')) {
                    document.body.innerHTML = "<h1 style='color: white; text-align: center; margin-top: 50px;'>WebGL is not supported. Use a modern browser like Chrome or Firefox.</h1>";
                    return;
                }

                // Setup renderer
                const canvas = document.getElementById("villageCanvas");
                const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.setPixelRatio(window.devicePixelRatio);

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(50, 45, 55);
                camera.lookAt(0, 0, 0);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);

                const sunlight = new THREE.DirectionalLight(0xfff5e6, 1.5);
                sunlight.position.set(30, 60, 30);
                sunlight.castShadow = true;
                sunlight.shadow.mapSize.width = 4096;
                sunlight.shadow.mapSize.height = 4096;
                sunlight.shadow.camera.near = 0.5;
                sunlight.shadow.camera.far = 150;
                sunlight.shadow.camera.left = -60;
                sunlight.shadow.camera.right = 60;
                sunlight.shadow.camera.top = 60;
                sunlight.shadow.camera.bottom = -60;
                scene.add(sunlight);

                // Ground
                const groundGeometry = new THREE.PlaneBufferGeometry(120, 120, 30, 30);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2f4f2f, roughness: 0.9, metalness: 0 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                const groundPositions = groundGeometry.attributes.position;
                for (let i = 0; i < groundPositions.count; i++) {
                    const z = groundPositions.getZ(i);
                    groundPositions.setZ(i, z + (Math.random() * 2 - 1));
                }
                groundPositions.needsUpdate = true;
                scene.add(ground);

                // Houses
                function createHouse(x, z, scale = 1) {
                    const house = new THREE.Group();
                    const wallGeometry = new THREE.BoxBufferGeometry(8 * scale, 5 * scale, 8 * scale);
                    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.6, metalness: 0.2 });
                    const walls = new THREE.Mesh(wallGeometry, wallMaterial);
                    walls.position.y = 2.5 * scale;
                    walls.castShadow = true;
                    walls.receiveShadow = true;
                    house.add(walls);

                    const doorGeometry = new THREE.BoxBufferGeometry(1.5 * scale, 3 * scale, 0.1 * scale);
                    const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x4A2F1A, metalness: 0.1 });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 1.5 * scale, 4.05 * scale);
                    house.add(door);

                    const windowGeometry = new THREE.BoxBufferGeometry(1.2 * scale, 1.2 * scale, 0.1 * scale);
                    const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, roughness: 0.2, metalness: 0.3 });
                    const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window1.position.set(2.5 * scale, 2.5 * scale, 4.05 * scale);
                    house.add(window1);
                    const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window2.position.set(-2.5 * scale, 2.5 * scale, 4.05 * scale);
                    house.add(window2);

                    const roofGeometry = new THREE.ConeBufferGeometry(5 * scale, 4 * scale, 4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.5, metalness: 0.1 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 5.5 * scale;
                    roof.rotation.y = Math.PI / 4;
                    roof.castShadow = true;
                    house.add(roof);

                    const chimneyGeometry = new THREE.BoxBufferGeometry(0.8 * scale, 2 * scale, 0.8 * scale);
                    const chimneyMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.2 });
                    const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
                    chimney.position.set(3 * scale, 6 * scale, -2 * scale);
                    chimney.castShadow = true;
                    house.add(chimney);

                    house.position.set(x, 0, z);
                    scene.add(house);
                }

                createHouse(10, 10, 1);
                createHouse(-15, 8, 0.9);
                createHouse(-12, -15, 1);
                createHouse(-22, 15, 0.8);
                createHouse(28, -10, 1.1);
                createHouse(32, 15, 0.95);
                createHouse(-28, 20, 1.2);
                createHouse(35, -15, 0.85);

                // Huts
                function createHut(x, z) {
                    const hut = new THREE.Group();
                    const baseGeometry = new THREE.CylinderBufferGeometry(3, 3, 4, 16);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.1 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 2;
                    base.castShadow = true;
                    hut.add(base);

                    const roofGeometry = new THREE.ConeBufferGeometry(3.5, 3, 16);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x964B00, roughness: 0.7 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 4.5;
                    roof.castShadow = true;
                    hut.add(roof);

                    hut.position.set(x, 0, z);
                    scene.add(hut);
                }

                createHut(-18, -18);
                createHut(20, -20);
                createHut(-27, 25);

                // Trees
                function createTree(x, z, scale = 1) {
                    const trunkGeometry = new THREE.CylinderBufferGeometry(0.4 * scale, 0.5 * scale, 5 * scale, 16);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.9 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, 2.5 * scale, z);
                    trunk.castShadow = true;
                    scene.add(trunk);

                    const leavesGeometry = new THREE.SphereBufferGeometry(3 * scale, 20, 20);
                    const leavesMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0x228B22 : 0x006400, 
                        roughness: 0.6 
                    });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(x, 6 * scale, z);
                    leaves.castShadow = true;
                    scene.add(leaves);
                }

                createTree(15, 15);
                createTree(-10, 18);
                createTree(12, -12);
                createTree(-18, 10);
                createTree(25, -8);
                createTree(-32, 12);
                createTree(38, 18, 0.9);
                createTree(-20, -20, 1.1);
                createTree(42, -22);

                // Forest Cluster
                for (let i = 0; i < 15; i++) {
                    const x = 45 + Math.random() * 15 - 7.5;
                    const z = 45 + Math.random() * 15 - 7.5;
                    createTree(x, z, 0.8 + Math.random() * 0.4);
                }

                // Lake with Waterfall
                const lakeGeometry = new THREE.CircleBufferGeometry(15, 32);
                const lakeMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF, roughness: 0.1, metalness: 0.4 });
                const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                lake.rotation.x = -Math.PI / 2;
                lake.position.set(-40, 0.01, 40);
                scene.add(lake);

                const waterfallGeometry = new THREE.PlaneBufferGeometry(5, 10);
                const waterfallMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, roughness: 0.2, metalness: 0.3, side: THREE.DoubleSide });
                const waterfall = new THREE.Mesh(waterfallGeometry, waterfallMaterial);
                waterfall.position.set(-40, 5, 50);
                scene.add(waterfall);

                // Rivers and Ponds
                const riverGeometry = new THREE.PlaneBufferGeometry(35, 10);
                const riverMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF, side: THREE.DoubleSide, roughness: 0.1, metalness: 0.4 });
                const river = new THREE.Mesh(riverGeometry, riverMaterial);
                river.rotation.x = -Math.PI / 2;
                river.position.set(0, 0.01, 25);
                scene.add(river);

                const pondGeometry = new THREE.CircleBufferGeometry(8, 32);
                const pondMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF, roughness: 0.1, metalness: 0.4 });
                const pond = new THREE.Mesh(pondGeometry, pondMaterial);
                pond.rotation.x = -Math.PI / 2;
                pond.position.set(40, 0.01, -25);
                scene.add(pond);

                // Ornate Bridge
                function createBridge(x, z) {
                    const bridge = new THREE.Group();
                    const deckGeometry = new THREE.BoxBufferGeometry(6, 0.6, 10);
                    const deckMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7 });
                    const deck = new THREE.Mesh(deckGeometry, deckMaterial);
                    deck.position.y = 0.6;
                    deck.castShadow = true;
                    bridge.add(deck);

                    const railGeometry = new THREE.BoxBufferGeometry(0.5, 2, 10);
                    const railMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.5, metalness: 0.3 });
                    const leftRail = new THREE.Mesh(railGeometry, railMaterial);
                    leftRail.position.set(2.75, 1.6, 0);
                    leftRail.castShadow = true;
                    bridge.add(leftRail);
                    const rightRail = new THREE.Mesh(railGeometry, railMaterial);
                    rightRail.position.set(-2.75, 1.6, 0);
                    rightRail.castShadow = true;
                    bridge.add(rightRail);

                    bridge.position.set(x, 0, z);
                    scene.add(bridge);
                }

                createBridge(0, 25);

                // Fields
                function createField(x, z) {
                    const fieldGeometry = new THREE.PlaneBufferGeometry(15, 15);
                    const fieldMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                    const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                    field.rotation.x = -Math.PI / 2;
                    field.position.set(x, 0.02, z);
                    scene.add(field);

                    const cropGeometry = new THREE.BoxBufferGeometry(0.5, 2.5, 0.5);
                    const cropMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                    for (let i = -6; i <= 6; i += 1) {
                        for (let j = -6; j <= 6; j += 1) {
                            const crop = new THREE.Mesh(cropGeometry, cropMaterial);
                            crop.position.set(x + i + Math.random() * 0.4, 1.25, z + j + Math.random() * 0.4);
                            crop.rotation.y = Math.random() * Math.PI;
                            crop.castShadow = true;
                            scene.add(crop);
                        }
                    }
                }

                createField(35, 35);
                createField(-35, -35);

                // Animals
                const cows = [];
                function createCow(x, z) {
                    const cow = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(3, 2, 1.5);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1;
                    body.castShadow = true;
                    cow.add(body);

                    const headGeometry = new THREE.BoxBufferGeometry(1.2, 1.2, 1.2);
                    const head = new THREE.Mesh(headGeometry, bodyMaterial);
                    head.position.set(0, 1.2, 1.5);
                    head.castShadow = true;
                    cow.add(head);

                    const legGeometry = new THREE.BoxBufferGeometry(0.5, 1.5, 0.5);
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                        leg.position.set(i % 2 === 0 ? 1.2 : -1.2, 0.5, i < 2 ? 0.5 : -0.5);
                        leg.castShadow = true;
                        cow.add(leg);
                    }

                    cow.position.set(x, 0, z);
                    scene.add(cow);
                    cows.push({ mesh: cow, velocity: new THREE.Vector3(0.01, 0, 0) });
                }

                createCow(18, 18);
                createCow(20, 16);
                createCow(-30, -12);

                const goats = [];
                function createGoat(x, z) {
                    const goat = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(2, 1.2, 1);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.7 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.6;
                    body.castShadow = true;
                    goat.add(body);

                    const headGeometry = new THREE.BoxBufferGeometry(0.8, 0.8, 0.8);
                    const head = new THREE.Mesh(headGeometry, bodyMaterial);
                    head.position.set(0, 0.8, 1);
                    head.castShadow = true;
                    goat.add(head);

                    const legGeometry = new THREE.BoxBufferGeometry(0.3, 1, 0.3);
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                        leg.position.set(i % 2 === 0 ? 0.8 : -0.8, 0.3, i < 2 ? 0.3 : -0.3);
                        leg.castShadow = true;
                        goat.add(leg);
                    }

                    goat.position.set(x, 0, z);
                    scene.add(goat);
                    goats.push({ mesh: goat, velocity: new THREE.Vector3(0.01, 0, 0) });
                }

                createGoat(25, 12);
                createGoat(-20, -15);

                const chickens = [];
                function createChicken(x, z) {
                    const chicken = new THREE.Group();
                    const bodyGeometry = new THREE.SphereBufferGeometry(0.6, 20, 20);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFA500, roughness: 0.6 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.6;
                    body.castShadow = true;
                    chicken.add(body);

                    const headGeometry = new THREE.SphereBufferGeometry(0.3, 16, 16);
                    const head = new THREE.Mesh(headGeometry, bodyMaterial);
                    head.position.set(0, 0.7, 0.6);
                    head.castShadow = true;
                    chicken.add(head);

                    const beakGeometry = new THREE.ConeBufferGeometry(0.2, 0.3, 12);
                    const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFF4500 });
                    const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                    beak.position.set(0, 0.7, 0.8);
                    beak.rotation.x = -Math.PI / 2;
                    beak.castShadow = true;
                    chicken.add(beak);

                    chicken.position.set(x, 0, z);
                    scene.add(chicken);
                    chickens.push({ mesh: chicken, velocity: new THREE.Vector3(0.005, 0, 0) });
                }

                createChicken(16, 7);
                createChicken(17, 6);
                createChicken(-15, -13);

                // Roads/Paths
                const roadGeometry = new THREE.PlaneBufferGeometry(50, 6);
                const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.8 });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.set(0, 0.03, 0);
                scene.add(road);

                const pathGeometry = new THREE.PlaneBufferGeometry(6, 40);
                const path = new THREE.Mesh(pathGeometry, roadMaterial);
                path.rotation.x = -Math.PI / 2;
                path.position.set(20, 0.03, 10);
                scene.add(path);

                // People
                const people = [];
                function createPerson(x, z) {
                    const person = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(0.8, 2.2, 0.8);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() * 0xffffff, 
                        roughness: 0.7 
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1.1;
                    body.castShadow = true;
                    person.add(body);

                    const headGeometry = new THREE.SphereBufferGeometry(0.45, 20, 20);
                    const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDAB9 });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 2.2;
                    head.castShadow = true;
                    person.add(head);

                    const armGeometry = new THREE.BoxBufferGeometry(0.4, 1.2, 0.4);
                    const armMaterial = new THREE.MeshStandardMaterial({ color: bodyMaterial.color });
                    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                    leftArm.position.set(0.8, 1.5, 0);
                    leftArm.castShadow = true;
                    person.add(leftArm);
                    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                    rightArm.position.set(-0.8, 1.5, 0);
                    rightArm.castShadow = true;
                    person.add(rightArm);

                    person.position.set(x, 0, z);
                    scene.add(person);
                    people.push({ mesh: person, velocity: new THREE.Vector3(0.02, 0, 0) });
                }

                createPerson(5, 5);
                createPerson(-6, -4);
                createPerson(20, 4);

                // Wells
                function createWell(x, z) {
                    const well = new THREE.Group();
                    const baseGeometry = new THREE.CylinderBufferGeometry(2, 2, 3, 20);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.5, metalness: 0.2 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 1.5;
                    base.castShadow = true;
                    well.add(base);

                    const roofGeometry = new THREE.ConeBufferGeometry(2.5, 2.5, 20);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 3.5;
                    roof.castShadow = true;
                    well.add(roof);

                    well.position.set(x, 0, z);
                    scene.add(well);
                }

                createWell(8, -18);
                createWell(-25, 10);

                // Temples
                function createTemple(x, z) {
                    const temple = new THREE.Group();
                    const baseGeometry = new THREE.BoxBufferGeometry(10, 8, 12);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.4, metalness: 0.2 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 4;
                    base.castShadow = true;
                    temple.add(base);

                    const roofGeometry = new THREE.BoxBufferGeometry(11, 2.5, 13);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 7.25;
                    roof.castShadow = true;
                    temple.add(roof);

                    const steepleGeometry = new THREE.CylinderBufferGeometry(0.8, 1, 6, 20);
                    const steeple = new THREE.Mesh(steepleGeometry, baseMaterial);
                    steeple.position.set(0, 10, 0);
                    steeple.castShadow = true;
                    temple.add(steeple);

                    temple.position.set(x, 0, z);
                    scene.add(temple);
                }

                createTemple(-22, -22);
                createTemple(30, 25);

                // Fences
                function createFence(xStart, zStart, length, direction = 'x') {
                    const fence = new THREE.Group();
                    const postGeometry = new THREE.CylinderBufferGeometry(0.25, 0.25, 4, 12);
                    const railGeometry = new THREE.BoxBufferGeometry(3, 0.25, 0.25);
                    const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.7, metalness: 0.1 });

                    for (let i = 0; i < length; i++) {
                        const post = new THREE.Mesh(postGeometry, fenceMaterial);
                        post.position.y = 2;
                        if (direction === 'x') post.position.set(xStart + i * 3, 0, zStart);
                        else post.position.set(xStart, 0, zStart + i * 3);
                        post.castShadow = true;
                        fence.add(post);

                        if (i < length - 1) {
                            const rail = new THREE.Mesh(railGeometry, fenceMaterial);
                            rail.position.y = 2;
                            if (direction === 'x') rail.position.set(xStart + i * 3 + 1.5, 0, zStart);
                            else rail.position.set(xStart, 0, zStart + i * 3 + 1.5);
                            rail.castShadow = true;
                            fence.add(rail);
                        }
                    }

                    scene.add(fence);
                }

                createFence(-10, -10, 6, 'x');
                createFence(10, -12, 5, 'z');
                createFence(25, 18, 6, 'x');
                createFence(-30, -10, 5, 'z');

                // Mountains
                function createMountain(x, z, scale = 1) {
                    const mountain = new THREE.Group();
                    const baseGeometry = new THREE.ConeBufferGeometry(20 * scale, 12 * scale, 16);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 6 * scale;
                    base.castShadow = true;
                    mountain.add(base);

                    const midGeometry = new THREE.ConeBufferGeometry(12 * scale, 8 * scale, 16);
                    const midMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.6 });
                    const mid = new THREE.Mesh(midGeometry, midMaterial);
                    mid.position.y = 14 * scale;
                    mid.castShadow = true;
                    mountain.add(mid);

                    const peakGeometry = new THREE.ConeBufferGeometry(6 * scale, 6 * scale, 16);
                    const peakMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.5 });
                    const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                    peak.position.y = 20 * scale;
                    peak.castShadow = true;
                    mountain.add(peak);

                    const rockGeometry = new THREE.SphereBufferGeometry(2 * scale, 12, 12);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
                    for (let i = 0; i < 10; i++) {
                        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                        rock.position.set(
                            (Math.random() - 0.5) * 16 * scale,
                            Math.random() * 10 * scale,
                            (Math.random() - 0.5) * 16 * scale
                        );
                        rock.castShadow = true;
                        mountain.add(rock);
                    }

                    mountain.position.set(x, 0, z);
                    scene.add(mountain);
                }

                createMountain(55, 55, 1);
                createMountain(-55, -55, 1.4);
                createMountain(50, -50, 1);

                // Windmill
                function createWindmill(x, z) {
                    const windmill = new THREE.Group();

                    const baseGeometry = new THREE.CylinderBufferGeometry(2, 2, 3, 20);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 1.5;
                    base.castShadow = true;
                    windmill.add(base);

                    const towerGeometry = new THREE.CylinderBufferGeometry(1.5, 2, 12, 20);
                    const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.5, metalness: 0.2 });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.y = 7.5;
                    tower.castShadow = true;
                    windmill.add(tower);

                    const doorGeometry = new THREE.BoxBufferGeometry(1, 2, 0.1);
                    const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033 });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 1, 2.05);
                    windmill.add(door);

                    const blades = new THREE.Group();
                    const bladeGeometry = new THREE.BoxBufferGeometry(10, 0.25, 0.5);
                    const bladeMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5F5, roughness: 0.6 });
                    for (let i = 0; i < 4; i++) {
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.z = 0.5;
                        blade.rotation.y = (Math.PI / 2) * i;
                        blade.castShadow = true;
                        blades.add(blade);
                    }
                    blades.position.set(0, 13.5, 0);
                    windmill.add(blades);

                    windmill.position.set(x, 0, z);
                    scene.add(windmill);
                    return blades;
                }

                const windmillBlades = createWindmill(-10, -20);

                // Watermill
                function createWatermill(x, z) {
                    const watermill = new THREE.Group();

                    const baseGeometry = new THREE.BoxBufferGeometry(8, 6, 10);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 3;
                    base.castShadow = true;
                    watermill.add(base);

                    const roofGeometry = new THREE.BoxBufferGeometry(9, 2, 11);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.6 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 6;
                    roof.castShadow = true;
                    watermill.add(roof);

                    const wheelGeometry = new THREE.CylinderBufferGeometry(3, 3, 1, 20);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.7 });
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(0, 3, 5.5);
                    wheel.castShadow = true;
                    watermill.add(wheel);

                    watermill.position.set(x, 0, z);
                    scene.add(watermill);
                    return wheel;
                }

                const watermillWheel = createWatermill(-40, 30);

                // Barn
                function createBarn(x, z) {
                    const barn = new THREE.Group();
                    const baseGeometry = new THREE.BoxBufferGeometry(12, 8, 14);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 4;
                    base.castShadow = true;
                    barn.add(base);

                    const roofGeometry = new THREE.BoxBufferGeometry(13, 3, 15);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.6 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 7.5;
                    roof.castShadow = true;
                    barn.add(roof);

                    const doorGeometry = new THREE.BoxBufferGeometry(4, 6, 0.1);
                    const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033 });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 3, 7.05);
                    barn.add(door);

                    barn.position.set(x, 0, z);
                    scene.add(barn);
                }

                createBarn(25, -25);

                // Cart
                function createCart(x, z) {
                    const cart = new THREE.Group();
                    const bodyGeometry = new THREE.BoxBufferGeometry(4, 1.5, 2.5);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1.5;
                    body.castShadow = true;
                    cart.add(body);

                    const wheelGeometry = new THREE.CylinderBufferGeometry(0.8, 0.8, 0.4, 16);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.6 });
                    for (let i = 0; i < 4; i++) {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.x = Math.PI / 2;
                        wheel.position.set(i % 2 === 0 ? 1.8 : -1.8, 0.8, i < 2 ? 0.8 : -0.8);
                        wheel.castShadow = true;
                        cart.add(wheel);
                    }

                    cart.position.set(x, 0, z);
                    scene.add(cart);
                }

                createCart(12, 0);

                // Marketplace
                function createMarketplace(x, z) {
                    const market = new THREE.Group();
                    const baseGeometry = new THREE.BoxBufferGeometry(15, 1, 15);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.8 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 0.5;
                    base.castShadow = true;
                    market.add(base);

                    const stallGeometry = new THREE.BoxBufferGeometry(4, 3, 4);
                    const stallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.5, metalness: 0.2 });
                    for (let i = 0; i < 4; i++) {
                        const stall = new THREE.Mesh(stallGeometry, stallMaterial);
                        stall.position.set(i % 2 === 0 ? -4 : 4, 2, i < 2 ? -4 : 4);
                        stall.castShadow = true;
                        market.add(stall);
                    }

                    market.position.set(x, 0, z);
                    scene.add(market);
                }

                createMarketplace(0, -30);

                // Castle
                function createCastle(x, z) {
                    const castle = new THREE.Group();
                    const baseGeometry = new THREE.BoxBufferGeometry(20, 10, 20);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.5, metalness: 0.2 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 5;
                    base.castShadow = true;
                    castle.add(base);

                    const towerGeometry = new THREE.CylinderBufferGeometry(3, 3, 15, 20);
                    const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.6 });
                    for (let i = 0; i < 4; i++) {
                        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                        tower.position.set(i % 2 === 0 ? -7 : 7, 12.5, i < 2 ? -7 : 7);
                        tower.castShadow = true;
                        castle.add(tower);
                    }

                    const roofGeometry = new THREE.ConeBufferGeometry(4, 5, 20);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.5 });
                    for (let i = 0; i < 4; i++) {
                        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                        roof.position.set(i % 2 === 0 ? -7 : 7, 20, i < 2 ? -7 : 7);
                        roof.castShadow = true;
                        castle.add(roof);
                    }

                    castle.position.set(x, 0, z);
                    scene.add(castle);
                }

                createCastle(40, -40);

                // Bushes
                function createBush(x, z, scale = 1) {
                    const bushGeometry = new THREE.SphereBufferGeometry(1.5 * scale, 20, 20);
                    const bushMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0x2E8B57 : 0x228B22, 
                        roughness: 0.7 
                    });
                    const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                    bush.position.set(x, 0.75 * scale, z);
                    bush.castShadow = true;
                    scene.add(bush);
                }

                createBush(6, 11, 1);
                createBush(-5, -15, 0.8);
                createBush(12, 8, 1.2);
                createBush(28, 5, 0.9);
                createBush(-12, 22, 1);
                createBush(15, -18, 0.85);

                // Rocks
                function createRock(x, z, scale = 1) {
                    const rockGeometry = new THREE.SphereBufferGeometry(1.5 * scale, 12, 12);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(x, 0.75 * scale, z);
                    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    rock.castShadow = true;
                    scene.add(rock);
                }

                createRock(18, 20, 1);
                createRock(-18, -8, 0.8);
                createRock(8, -25, 1.2);
                createRock(45, 30, 0.9);

                // Sun
                const sunGeometry = new THREE.SphereBufferGeometry(3, 32, 32);
                const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFE0 });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                sun.position.set(30, 35, 30);
                scene.add(sun);

                // Clouds
                const clouds = [];
                function createCloud(x, y, z) {
                    const cloud = new THREE.Group();
                    const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.8 });
                    for (let i = 0; i < 7; i++) {
                        const puffGeometry = new THREE.SphereBufferGeometry(2 + Math.random() * 0.5, 20, 20);
                        const puff = new THREE.Mesh(puffGeometry, cloudMaterial);
                        puff.position.set(i * 3 - 9, Math.random() * 1, Math.random() * 2);
                        puff.castShadow = true;
                        cloud.add(puff);
                    }
                    cloud.position.set(x, y, z);
                    scene.add(cloud);
                    clouds.push(cloud);
                }

                createCloud(18, 22, 8);
                createCloud(-15, 25, -6);
                createCloud(25, 23, -8);
                createCloud(-25, 26, 16);

                // Birds
                const birds = [];
                function createBird(x, y, z) {
                    const bird = new THREE.Group();
                    const bodyGeometry = new THREE.SphereBufferGeometry(0.35, 20, 20);
                    const wingGeometry = new THREE.BoxBufferGeometry(0.8, 0.05, 0.6);
                    const birdMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.7 });

                    const body = new THREE.Mesh(bodyGeometry, birdMaterial);
                    body.castShadow = true;
                    bird.add(body);

                    const leftWing = new THREE.Mesh(wingGeometry, birdMaterial);
                    leftWing.position.set(0.45, 0, 0);
                    leftWing.castShadow = true;
                    bird.add(leftWing);

                    const rightWing = new THREE.Mesh(wingGeometry, birdMaterial);
                    rightWing.position.set(-0.45, 0, 0);
                    rightWing.castShadow = true;
                    bird.add(rightWing);

                    bird.position.set(x, y, z);
                    scene.add(bird);
                    birds.push({ mesh: bird, velocity: new THREE.Vector3(0.05, 0, 0) });
                }

                createBird(8, 16, 8);
                createBird(-8, 18, -8);
                createBird(16, 22, -5);
                createBird(-16, 20, 5);

                // Controls
                const controls = new THREE.OrbitControls(camera, canvas);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                controls.minDistance = 10;
                controls.maxDistance = 100;

                // Resize handler
                window.addEventListener('resize', () => {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                });

                // Animation
                let time = 0;
                function animate() {
                    requestAnimationFrame(animate);
                    time += 0.02;

                    sun.scale.set(
                        1 + Math.sin(time) * 0.05,
                        1 + Math.sin(time) * 0.05,
                        1 + Math.sin(time) * 0.05
                    );

                    windmillBlades.rotation.x += 0.05;
                    watermillWheel.rotation.x += 0.03;

                    clouds.forEach(cloud => {
                        cloud.position.x += 0.02;
                        if (cloud.position.x > 60) cloud.position.x = -60;
                    });

                    birds.forEach(bird => {
                        bird.mesh.position.add(bird.velocity);
                        bird.mesh.children[1].rotation.z = Math.sin(time * 2) * 0.5;
                        bird.mesh.children[2].rotation.z = -Math.sin(time * 2) * 0.5;
                        if (bird.mesh.position.x > 55 || bird.mesh.position.x < -55) {
                            bird.velocity.x *= -1;
                        }
                    });

                    cows.forEach(cow => {
                        cow.mesh.position.add(cow.velocity);
                        if (cow.mesh.position.x > 30 || cow.mesh.position.x < 16) {
                            cow.velocity.x *= -1;
                        }
                    });

                    goats.forEach(goat => {
                        goat.mesh.position.add(goat.velocity); // Fixed error: was cow.mesh
                        if (goat.mesh.position.x > 30 || goat.mesh.position.x < -30) {
                            goat.velocity.x *= -1;
                        }
                    });

                    chickens.forEach(chicken => {
                        chicken.mesh.position.add(chicken.velocity);
                        if (chicken.mesh.position.x > 20 || chicken.mesh.position.x < -20) {
                            chicken.velocity.x *= -1;
                        }
                    });

                    people.forEach(person => {
                        person.mesh.position.add(person.velocity);
                        if (person.mesh.position.x > 25 || person.mesh.position.x < -25) {
                            person.velocity.x *= -1;
                        }
                    });

                    renderer.render(scene, camera);
                    controls.update();
                }
                animate();

                console.log("Ultra-Luxurious Responsive 3D Village Scene initialized successfully!");
            } catch (error) {
                console.error("Error initializing scene:", error);
                document.body.innerHTML = "<h2 style='color: red; text-align: center; margin-top: 50px;'>Error loading scene. Check console (F12) for details.</h2>";
            }
        });
    </script>
</body>
</html>
